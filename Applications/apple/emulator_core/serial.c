#include "serial.h"
#include "board.h"
#include "io_addr.h"
#include "cpu.h"
#include "ram_ctrl.h"
#include "tima_libc.h"
#include "led_frame.h"

#ifdef ENABLE_EMBEDDED_ASM
#include "embedded.h"
#endif

//////////////////////////////////////////////////////////////////////////////////////

//#define SERIAL_USE_FILE
#define SERIAL_FW_BINARY		"rom/serial_fw.bin"
#define SERIAL_FW_SOURCE		"fw/serial_driver/serial_src.asm"

//////////////////////////////////////////////////////////////////////////////////////

#ifdef SERIAL_USE_FILE

static uint8_t serial_fw[4096];
static char * serial_source_list[2] = 
{
	SERIAL_FW_SOURCE,
	NULL
};

#else

static const uint8_t serial_fw[4096] =
{
	0x2C, 0x58, 0xFF, 0x70, 0x0C, 0x38, 0x90, 0x18, 0xB8, 0x50, 0x06, 0x01, 0x31, 0x8E, 0x94, 0x97,
	0x9A, 0x85, 0x27, 0x86, 0x35, 0x8A, 0x48, 0x98, 0x48, 0x08, 0x78, 0x8D, 0xFF, 0xCF, 0x20, 0x58,
	0xFF, 0xBA, 0xBD, 0x00, 0x01, 0x8D, 0xF8, 0x07, 0xAA, 0x0A, 0x0A, 0x0A, 0x0A, 0x85, 0x26, 0xA8,
	0x28, 0x50, 0x29, 0x1E, 0x38, 0x05, 0x5E, 0x38, 0x05, 0xB9, 0x8A, 0xC0, 0x29, 0x1F, 0xD0, 0x05,
	0xA9, 0xEF, 0x20, 0x05, 0xC8, 0xE4, 0x37, 0xD0, 0x0B, 0xA9, 0x07, 0xC5, 0x36, 0xF0, 0x05, 0x85,
	0x36, 0x18, 0x90, 0x08, 0xE4, 0x39, 0xD0, 0xF9, 0xA9, 0x05, 0x85, 0x38, 0xBD, 0x38, 0x07, 0x29,
	0x02, 0x08, 0x90, 0x03, 0x4C, 0xBF, 0xC8, 0xBD, 0xB8, 0x04, 0x48, 0x0A, 0x10, 0x0E, 0xA6, 0x35,
	0xA5, 0x27, 0x09, 0x20, 0x9D, 0x00, 0x02, 0x85, 0x27, 0xAE, 0xF8, 0x07, 0x68, 0x29, 0xBF, 0x9D,
	0xB8, 0x04, 0x28, 0xF0, 0x06, 0x20, 0x63, 0xCB, 0x4C, 0xB5, 0xC8, 0x4C, 0xFC, 0xC8, 0x20, 0x00,
	0xC8, 0xA2, 0x00, 0x60, 0x4C, 0x9B, 0xC8, 0x4C, 0xAA, 0xC9, 0x4A, 0x20, 0x9B, 0xC9, 0xB0, 0x08,
	0x20, 0xF5, 0xCA, 0xF0, 0x06, 0x18, 0x90, 0x03, 0x20, 0xD2, 0xCA, 0xBD, 0xB8, 0x05, 0xAA, 0x60,
	0xA2, 0x03, 0xB5, 0x36, 0x48, 0xCA, 0x10, 0xFA, 0xAE, 0xF8, 0x07, 0xBD, 0x38, 0x06, 0x85, 0x36,
	0xBD, 0xB8, 0x04, 0x29, 0x38, 0x4A, 0x4A, 0x4A, 0x09, 0xC0, 0x85, 0x37, 0x8A, 0x48, 0xA5, 0x27,
	0x48, 0x09, 0x80, 0x20, 0xED, 0xFD, 0x68, 0x85, 0x27, 0x68, 0x8D, 0xF8, 0x07, 0xAA, 0x0A, 0x0A,
	0x0A, 0x0A, 0x85, 0x26, 0x8D, 0xFF, 0xCF, 0xA5, 0x36, 0x9D, 0x38, 0x06, 0xA2, 0x00, 0x68, 0x95,
	0x36, 0xE8, 0xE0, 0x04, 0x90, 0xF8, 0xAE, 0xF8, 0x07, 0x60, 0xC1, 0xD0, 0xD0, 0xCC, 0xC5, 0x08,
};

#endif

//////////////////////////////////////////////////////////////////////////////////////

static uint8_t serial_control;
static uint8_t serial_command;
static uint8_t serial_status;

static board_data_t * board;

//////////////////////////////////////////////////////////////////////////////////////

static uint8_t serial_io_controller_read( uint8_t address, uint8_t data )
{
	switch( address & 0x0F )
	{
		case 0x01:
		case 0x02:
			return 0;

		case 0x08:
			// receive
			return 0;

		case 0x09:
			// status
			return serial_status;

		case 0x0A:
			//command
			return serial_command;

		case 0x0B:
			// control
			return serial_control;

	}

	return 0;
}

static uint8_t serial_io_controller_write( uint8_t address, uint8_t data )
{
	char temp[2];

	switch( address & 0x0F )
	{
		case 0x08:
			// transmit
			temp[0] = data;
			temp[1] = 0;
			board->p_print( temp );
			break;

		case 0x0A:
			//command
			serial_command = data;
			break;

		case 0x0B:
			// control
			serial_control = data;
			break;
	}

	return 0;
}

#ifdef SERIAL_USE_FILE
void serial_fw_rebuild( bool_t force_build )
{
	if( ( board_disc_image_access( SERIAL_FW_BINARY, Disc_Mode_Size, 0, ( uint8_t * )&serial_fw[0], 256 ) == 0 ) ||
		( force_build == TRUE ) )
	{
		#ifdef _USE_EMBEDDED_ASM
		assembler( serial_source_list, 1, SERIAL_FW_BINARY, board );
		#endif
	}
}
#endif

void serial_insert( uint8_t slot )
{
	int counter;
	uint8_t page = ( 0x08 + slot ) << 4;

	#ifdef SERIAL_USE_FILE
	serial_fw_rebuild( FALSE );
    board_disc_image_access( SERIAL_FW_BINARY, Disc_Mode_Read, 0, ( uint8_t * )&serial_fw[0], 256 );
	#endif

	ram_ctrl_insert_slot( slot, ( uint8_t * )serial_fw );

	for( counter = 0; counter < 16; counter++ )
	{
		memory_io_set_handler( page + counter, serial_io_controller_read, serial_io_controller_write );
	}
}

void serial_init( void * p_board )
{
	board = ( board_data_t * )p_board;

	serial_control = 0x1F;
	serial_command = 0;
	serial_status = 0x10;
}

